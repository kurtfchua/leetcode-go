func numIslands(grid [][]byte) int {
    ROWS, COLS := len(grid), len(grid[0])
    count := 0

    for r := 0; r < ROWS; r ++{
        for c := 0; c < COLS; c ++{
            if grid[r][c] == '1'{
                //bfs(grid, r,c)
                dfs(grid, ROWS, COLS, r,c)
                count++
            }
        }
    }

    return count
}

func dfs(grid [][]byte, ROWS int, COLS int, r int, c int){
    if 0 > r || r >= ROWS || 0 > c || c >= COLS || grid[r][c] == '0'{
        return
    } 
    grid[r][c] = '0'
    dfs(grid, ROWS, COLS, r,c+1)
    dfs(grid, ROWS, COLS,r+1, c)
    dfs(grid, ROWS, COLS,r-1,c)
    dfs(grid, ROWS, COLS,r,c-1)
}

func bfs(grid [][]byte, r int, c int){
    ROWS, COLS := len(grid), len(grid[0])
    queue := [][]int{{r,c}}
    grid[r][c] = '0'

    for len(queue) > 0{
        r, c := queue[0][0], queue[0][1]
        queue = queue[1:]
        directions := [][]int{{0,1},{1,0},{0,-1},{-1,0}}
        for _, dir := range directions{
            dr, dc := dir[0], dir[1]
            if 0 <= r +dr && r +dr < ROWS && 0 <= c +dc && c +dc < COLS && grid[r+dr][c+dc] == '1'{
                queue = append(queue, []int{r+dr, c+dc})
                grid[r+dr][c+dc] = '0'
            }
        }
    }

}